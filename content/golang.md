---
title: Implementing Webauthn in Golang
---

This section is dedicated to a framework-agnostic implementation of a Webauthn workflow using the Go programming language.
Whenever possible, I try to use just the standard library, so with enough knowledge of the Go ecosystem, you should be able to modify the solution to use your preferred libraries.

## Who this text is for

This website is not meant as a complete learning resource for beginners, but rather a more or less comprehensive overview of Webauthn that I wished were available when I was learning about this technology.

This text assumes that you are an experienced Web developer, with reasonably good knowledge of back end development, the UNIX command line, SQL, and all three languages used in browser environments (HTML, CSS, and JavaScript).
Therefore I won't be stopping to explain code snippets that I believe should be readable without explanation.

If you have any suggestions for improvements to the tutorial, feel free to [reach out to me](https://github.com/moroz) or to submit a Pull Request or an issue in the [Github repository](https://github.com/moroz/webauthn.academy) of this website.

## Initial setup

The following walkthrough sets up a password authentication from scratch. Once this text is finalized, you will be able to skip to the section where I start implementing Webauthn. For now, you can just follow along.

Command-line tools we will be using: [mise](https://mise.jdx.dev/), [goose](https://github.com/pressly/goose), [direnv](https://direnv.net/).
For persistence, I will be using PostgreSQL 16.2, but any reasonably modern version of PostgreSQL should work too.

Create a directory for the new project:

```plain
mkdir academy-go
```

Ensure Golang is installed (here using [mise](https://mise.jdx.dev/)):

```plain
cd academy-go
mise install go@1.22.3
mise local go
```

Initialize a Go module in this directory.

```shell
# Swap "moroz" for your Github username
go mod init github.com/moroz/webauthn-academy-go
```

Initialize a Git repository in this directory:

```shell
git init
git branch -M main
git add .
git commit -m "Initial commit"
```

We will be writing database migrations using [goose](https://github.com/pressly/goose).
Install goose in your PATH using the following command:

```plain
go install github.com/pressly/goose/v3/cmd/goose@latest
```

Install [sqlx](https://jmoiron.github.io/sqlx/) and the PostgreSQL driver [pq](https://github.com/lib/pq):

```plain
go install github.com/lib/pq
go install github.com/jmoiron/sqlx
```

Now, let's set up a database. First, create a `.envrc` file. We will be using this file to set environment variables using [direnv](https://direnv.net/).

```shell
export PGDATABASE=academy_dev
export DATABASE_URL="postgres://postgres:postgres@localhost/${PGDATABASE}?sslmode=disable"
export GOOSE_MIGRATION_DIR=db/migrations
export GOOSE_DRIVER=postgres
export GOOSE_DBSTRING="$DATABASE_URL"
```

By setting the `GOOSE_MIGRATION_DIR` environment variable, we instruct Goose to look for migration files in the `db/migrations` directory.
The `GOOSE_DBSTRING` makes Goose run the migration scripts against our development database.
In the command line, source this script or run `direnv allow` to apply these settings:

```shell
# If you have configured direnv
direnv allow
# Otherwise just source this file
source .envrc
```

Generate a migration file for the `users` table:

```plain
goose create create_users sql
```

In the newly created migration file (called `db/migrations/20240511103916_create_users.sql` in my case, the timestamp part will be different for you), add instructions to create and tear down a `users` table:

```sql
-- +goose Up
-- +goose StatementBegin
create extension if not exists citext;

create table users (
  id bigint primary key generated by default as identity,
  email citext not null unique,
  display_name varchar(80) not null,
  password_hash varchar(100) not null,
  inserted_at timestamp(0) not null default (now() at time zone 'utc'),
  updated_at timestamp(0) not null default (now() at time zone 'utc')
);
-- +goose StatementEnd

-- +goose Down
-- +goose StatementBegin
drop table users;
-- +goose StatementEnd
```

In `types/user.go`, define types representing records in the `users` table and new user registration params:

```go
package types

import "time"

type User struct {
	ID           int       `db:"id"`
	Email        string    `db:"email"`
	DisplayName  string    `db:"display_name"`
	PasswordHash string    `db:"password_hash"`
	InsertedAt   time.Time `db:"inserted_at"`
	UpdatedAt    time.Time `db:"updated_at"`
}

type NewUserParams struct {
	Email                string `schema:"email" validate:"required|email"`
	DisplayName          string `schema:"displayName" validate:"required"`
	Password             string `schema:"password" validate:"required|min_len:8|max_len:80"`
	PasswordConfirmation string `schema:"passwordConfirmation" validate:"required|eq_field:Password"`
}
```

On the `User` type, we define `db:` annotations, so that `sqlx` can map database columns to struct fields (these are not required if the struct field names match database columns).
On the `NewUserParams` struct type, we define annotations for [gorilla/schema](https://github.com/gorilla/schema) and [gookit/validate](https://github.com/gookit/validate). Later on, we will be using `gorilla/schema` to convert HTTP POST data to structs. `gookit/validate` is a simple validation library.

For reasons I cannot fathom, the Golang ecosystem has settled on the [go-playground/validator](https://pkg.go.dev/github.com/go-playground/validator) library as the state of the art in terms of struct validation.
I have found this library to be good for validation, but a pain in the neck whenever I had to customize error messages.
`gookit/validate` is much simpler, and customizing error messages is much simpler as well.

In `store/user_store.go`, define a `userStore` struct. We will be using this type to implement basic CRUD (**C**reate-**R**ead-**U**pdate-**D**elete) operations. For now, let's write an `InsertUser` method to insert pre-validated records into the database. Later on, we will be building on top of this method to implement a user registration workflow.

```go
package store

import (
	"github.com/jmoiron/sqlx"
	"github.com/moroz/webauthn-academy-go/types"
)

type UserStore struct {
	db *sqlx.DB
}

func NewUserStore(db *sqlx.DB) UserStore {
	return UserStore{db}
}

const insertUserQuery = `insert into users (email, display_name, password_hash) values ($1, $2, $3) returning *`

func (s *UserStore) InsertUser(user *types.User) (*types.User, error) {
	var result types.User
	err := s.db.Get(&result, insertUserQuery, user.Email, user.DisplayName, user.PasswordHash)
	if err != nil {
		return nil, err
	}
	return &result, nil
}
```

In `service/user_service.go`, define a `UserService` type. We will be using this type to implement higher-level database interactions.
While the `InsertUser` function in the previous example was a simple `INSERT` operation, the `RegisterUser` method on the `UserService` struct also handles data validation using `gookit/validate` and password hashing using [alexedwards/argon2id](https://github.com/alexedwards/argon2id).

```go
package service

import (
	"github.com/alexedwards/argon2id"
	"github.com/gookit/validate"
	"github.com/jmoiron/sqlx"
	"github.com/lib/pq"
	"github.com/moroz/webauthn-academy-go/store"
	"github.com/moroz/webauthn-academy-go/types"
)

func init() {
	validate.Config(func(opt *validate.GlobalOption) {
		opt.StopOnError = false
	})
}

type UserService struct {
	store store.UserStore
}

func NewUserService(db *sqlx.DB) UserService {
	return UserService{store.NewUserStore(db)}
}

func (s *UserService) RegisterUser(params types.NewUserParams) (*types.User, error, validate.Errors) {
	v := validate.Struct(params)

	if !v.Validate() {
		return nil, nil, v.Errors
	}

	passwordHash, err := argon2id.CreateHash(params.Password, argon2id.DefaultParams)
	if err != nil {
		return nil, err, nil
	}

	user, err := s.store.InsertUser(&types.User{
		Email:        params.Email,
		PasswordHash: passwordHash,
		DisplayName:  params.DisplayName,
	})

	if err == nil {
		return user, nil, nil
	}

	// https://www.postgresql.org/docs/current/errcodes-appendix.html
	// Error 23505 `unique_violation` means that a unique constraint has
    // prevented us from inserting a duplicate value. Instead of returning
    // a raw error, we return a handcrafted validation error that we can
    // later display in a form.
	if err, ok := err.(*pq.Error); ok && err.Code == "23505" && err.Constraint == "users_email_key" {
		validationErrors := validate.Errors{}
		validationErrors.Add("Email", "unique", "has already been taken")
		return nil, nil, validationErrors
	}

	return nil, err, nil
}
```

### Prepare a test suite

Next, we can test our data validation and the registration logic using unit tests.
Go comes with a built-in testing engine, but writing tests with just the standard library tooling is very tedious and repetitive.
Therefore we are going to install [stretchr/testify](https://pkg.go.dev/github.com/stretchr/testify).

Then, in `.envrc`, define two new environment variables: `TEST_DATABASE_NAME` and `TEST_DATABASE_URL`.
We will be using these variables to create and connect to the test database.
Then, define Makefile targets to prepare the test database and run the test suites:

```makefile
guard-%:
	@ test -n "${$*}" || (echo "FATAL: Environment variable $* is not set!"; exit 1)

db.test.prepare: guard-TEST_DATABASE_NAME guard-TEST_DATABASE_URL
	@ createdb ${TEST_DATABASE_NAME} 2>/dev/null || true
	@ env GOOSE_DBSTRING="${TEST_DATABASE_URL}" goose up

test: db.test.prepare
	go test -v ./...
```

This file utilizes GNU `make` syntax extensions to define a dynamic `guard-%` target, which ensures that each required environment variable is set and non-empty.
We then use these guards to validate the environment before running the `db.test.prepare` target, which creates a test database and runs migrations against this database.
Finally, the `test` target runs the test suites of all packages in the project. Since the `test` target lists `db.test.prepare` as a dependency, `make` will ensure that all the migrations are correctly applied against the test database before the test suites are executed.

In `service/service_test.go`, define a test suite using `stretchr/testify`. This file does not define any specific tests, only a framework.

```go
package service_test

import (
	"os"
	"testing"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
	"github.com/stretchr/testify/suite"
)

type ServiceTestSuite struct {
	suite.Suite
	db *sqlx.DB
}

func (s *ServiceTestSuite) SetupTest() {
	conn := os.Getenv("TEST_DATABASE_URL")
	s.db = sqlx.MustConnect("postgres", conn)
	s.db.MustExec("truncate users cascade")
}

func TestServiceTestSuite(t *testing.T) {
	suite.Run(t, new(ServiceTestSuite))
}
```

With this file in place, we can set up more specific tests for registration logic. In `service/user_registration.go`, add tests for the user service:

```go
package service_test

import (
	"github.com/alexedwards/argon2id"
	"github.com/moroz/webauthn-academy-go/service"
	"github.com/moroz/webauthn-academy-go/store"
	"github.com/moroz/webauthn-academy-go/types"
)

func (s *ServiceTestSuite) TestRegisterUser() {
	params := types.NewUserParams{
		Email:                "registration@example.com",
		DisplayName:          "Example User",
		Password:             "foobar123123",
		PasswordConfirmation: "foobar123123",
	}

	srv := service.NewUserService(s.db)
	user, err, _ := srv.RegisterUser(params)
	s.NoError(err)
	s.Equal(params.Email, user.Email)
	s.Equal(params.DisplayName, user.DisplayName)

	match, err := argon2id.ComparePasswordAndHash(params.Password, user.PasswordHash)
	s.True(match)
}

func (s *ServiceTestSuite) TestRegisterUserWithInvalidParams() {
	params := types.NewUserParams{
		Email:                "invalid",
		DisplayName:          "Example User",
		Password:             "short",
		PasswordConfirmation: "not matching",
	}

	srv := service.NewUserService(s.db)
	user, err, validationErrors := srv.RegisterUser(params)
	s.NoError(err)
	s.Nil(user)
	msg := validationErrors.FieldOne("Email")
	s.Equal("is not a valid email address", msg)
	msg = validationErrors.FieldOne("Password")
	s.Equal("must be between 8 and 80 characters long", msg)
	msg = validationErrors.FieldOne("PasswordConfirmation")
	s.Contains(msg, "do not match")
}

func (s *ServiceTestSuite) TestRegisterUserWithDuplicateEmail() {
	store := store.NewUserStore(s.db)
	user, err := store.InsertUser(&types.User{
		Email:        "duplicate@email.com",
		PasswordHash: "test",
		DisplayName:  "John Smith",
	})

	s.NoError(err)

	srv := service.NewUserService(s.db)

	params := types.NewUserParams{
		Email:                user.Email,
		DisplayName:          "Other User",
		Password:             "foobar123123",
		PasswordConfirmation: "foobar123123",
	}
	user, err, validationErrors := srv.RegisterUser(params)
	s.Nil(user)
	s.Nil(err)
	msg := validationErrors.FieldOne("Email")
	s.Equal("has already been taken", msg)
}
```
