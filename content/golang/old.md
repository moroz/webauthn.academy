
## Create a configuration package

In `config/config.go`, add a module to encapsulate the logic for reading and validating application configuration from environment variables.

{{< file "golang/005-config-helper.go" "go" >}}

The helper function `MustGetenv` wraps [`os.Getenv`](https://pkg.go.dev/os#Getenv) so that if any required environment variable is unset or empty, the function will log an error message and terminate the program. Failing early helps identify configuration errors early on, and putting configuration in a single, independent package allows us to import this package anywhere in the program, without having to worry about circular dependency errors.

### Set up `templ` for HTML templating

We will be building templates using [templ](https://templ.guide/) instead of Go's built-in `html/template` package.
This is because Templ makes it much easier to share common data between views (such as flash messages, authentication status, page title, etc.).
Install the templ CLI:

```plain
go install github.com/a-h/templ/cmd/templ@latest
```

Next, define the basic HTML layouts at `templates/layout/root.templ`:

{{< file "golang/007-root.templ" "templ" >}}

We define two layout templates: `RootLayout`, which is the base HTML layout for all context-specific layouts in the application, and `Unauthenticated`, a basic layout used for views shown to unauthenticated visitors, such as the login page or the registration page.

In `templates/users/users.templ`, add the registration form template:

{{< file "golang/008-users.templ" "templ" >}}

You can generate Go code from `.templ` files using this command:

```plain
templ generate
```

Now we can write a handler that will render these templates in response to HTTP requests.
In `handler/user_handler.go`, add the following:

{{< file "golang/009-users-handler.go" "go" >}}

Update `main.go` to serve requests to `GET /` with this handler:

{{< file "golang/010-main.go" "go" >}}

Do note that in line 10 we need to import the [`github.com/lib/pq`](https://github.com/lib/pq) library using an `import` statement with the blank identifier `_` as an [explicit package name](https://go.dev/ref/spec#Import_declarations). This package is never called directly, but this import statement is required for its side effects. If you forget to add this import, the call to [`sqlx.MustConnect`](https://pkg.go.dev/github.com/jmoiron/sqlx#MustConnect) will result in a panic.

If you re-run this project now (using `go run .` in the project's root directory) and navigate to [localhost:3000](http://localhost:3000), you should be greeted with an unstyled registration form like the one below:

{{< figure "/golang/02-sign-up-without-css.png" "The sign up page rendered without CSS at 200% zoom." >}}

Now, let's set up some styling.

### Set up Vite for asset bundling

We will be using [Vite](https://vitejs.dev/) to compile and bundle CSS and JavaScript assets.
First, install the [pnpm package manager](https://pnpm.io/) for node using `npm`:

```plain
npm i -g pnpm
```

Then, create a Vite project under `assets/`:

```plain
pnpm create vite@latest assets --template vanilla-ts
cd assets
pnpm install
```

### Code reloading with `modd`

With Vite added to the project, we will have to run the Vite development server in the background alongside the application.
At this point, running multiple commands (`templ generate` and `go run .`) just to rebuild the code could already become very tedious.
Let's set up [modd](https://github.com/cortesi/modd) to rebuild templates and application code.

Start by installing `modd`:

```plain
go install github.com/cortesi/modd/cmd/modd@latest
```

Then, in a file named `modd.conf` in the root directory of the project, add the following configuration:

```plain
{
  daemon +sigterm: cd assets/ && pnpm run dev --port=5173
}

**/*.templ {
  prep +onchange: templ generate
}

**/*.go !**/*_test.go {
  prep +onchange: go build -o server .
  daemon +sigterm: ./server
}
```

This file instructs `modd` to:

* always start the Vite development server in the background whenever we start the project,
* regenerate view code whenever a `.templ` file is modified,
* rebuild and restart the application whenever `.go` files are modified (including view code).

Update `.gitignore` to look like this:

```shell
# Compiled server executable
/server

# Go code generated by templ
**/*_templ.go

# Environment variables (machine-specific values and secrets)
.envrc
```

Now, terminate the application server if you still had it running, and run `modd` in the terminal.
With a correct setup, the tool should regenerate your views and start the Vite development server:

```plain
$ modd
20:06:47: skipping prep: templ generate
20:06:47: skipping prep: go build -o server .
20:06:47: daemon: cd assets/ && pnpm run dev --port=5173
>> starting...
20:06:47: daemon: ./server
>> starting...
2024/05/20 20:06:47 Listening on port 3000
```

### Style the page with CSS

Now we can add some CSS to make the page more presentable. We will be writing CSS by hand to show you how simple this can be.

Install [dart-sass](https://sass-lang.com/) to compile stylesheets:

```plain
pnpm add sass
```

Create an empty directory at `assets/src/css` and an empty file therein:

```plain
mkdir -p assets/src/css
touch assets/src/css/style.scss
```

Replace the contents of `assets/src/main.ts` with a single line, importing the SCSS entrypoint file:

```javascript
import "./css/style.scss";
```

In the `RootLayout` template in `templates/layout/root.templ`, add a `<script>` tag to load assets with Vite:

{{< file "golang/011-root.templ" "templ" >}}

In development, this change is enough to load the Vite project in the browser, and the script will automatically inject CSS into the DOM.
However, in production builds, the JavaScript files will be compiled and minified into separate JavaScript and CSS files, and we will need to load them separately.
This is a bit more involved than the above example, however we don't really need to think about this until we start preparing the project for production deployments.

In `assets/src/css/_palette.scss`, add a few colors (they are all borrowed from [a certain CSS toolkit that I otherwise don't want to use](https://tailwindcss.com/docs/customizing-colors), but it's okay since the aforementioned toolkit is MIT-licensed).

{{< file "golang/012-palette.scss" "scss" >}}

First, let's add some styles to center the form within the page:

{{< file "golang/013-style.scss" "scss" >}}

With these changes in place, the form should be displayed in a white card, centered on a light-green page:

{{< figure "/golang/03-sign-up-with-layout.png" "Partly styled sign up page at 200% zoom." >}}

Then, let's style the form fields and the submit button:

{{< file "golang/014-style.scss" "scss" >}}

The sign up page should now begin to look like this:

{{< figure "/golang/04-sign-up-styled.png" "Fully styled sign up page at 200% zoom." >}}

## Sign up handler

Now that the registration form is rendering correctly, we can implement the handler that will process the data submitted by that form.
Since the form is using the POST HTTP method and is not marked as `multipart` (which is only necessary if you want to upload files together with other data in a single request), the request body will be submitted in URL-encoded format ([`application/x-www-form-urlencoded`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST)).
Once the request reaches the handler, we can parse the data using [`net/http.Request.ParseForm`](https://pkg.go.dev/net/http#Request.ParseForm), which will populate the [`PostForm`](https://pkg.go.dev/net/http#Request) field on the Request struct.
In order to convert the data to a `types.NewUserParams` struct, we could do something like this:

```go {hl_lines=[1 2 3]}
if err := r.ParseForm(); err != nil {
    // handle bad request
    return
}

var params types.NewUserParams
params.Email = r.PostForm.Get("email")
params.DisplayName = r.PostForm.Get("displayName")
params.Password = r.PostForm.Get("password")
params.PasswordConfirmation = r.PostForm.Get("passwordConfirmation")

// actually try to create a User
```

As you can imagine, this approach could become extremely tedious, especially if at some point we decided to submit multiple values per form field (e. g. multiple checkboxes in a fieldset).
Therefore, we are going to use [github.com/gorilla/schema](https://github.com/gorilla/schema) to handle this task for us.

First, install the library:

```plain
go get github.com/gorilla/schema
```

Then, in a new file called `handler/helpers.go`, add the following:

{{< file "golang/015-helpers.go" "go" >}}

The `decoder` variable is a shared instance of the schema decoder that we can use to decode the data submitted by multiple requests.
The `handleError` function is a helper that will help us quickly terminate unprocessable requests with a simple response based on a HTTP status code.

In `handler/user_handler.go`, add a `Create` method that will handle the user creation action.

{{< file "golang/016-create-user.go" "go" >}}

In this method, we decode the submitted HTTP POST data into a `types.NewUserParams` struct, and if the data cannot be parsed, we return a simple [`400 Bad Request`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400) error response.
Then we validate the params and attempt to insert them into the database. If the validation fails, we re-render the registration form with error messages. Finally, if everything goes smooth, we redirect the user to the `/sign-in` path, which we have not implemented yet.

## Sign in page

In `templates/sessions/sessions.templ`, add a template for the sign in form:

{{< file "golang/017-sessions.templ" "templ" >}}

Then, in `handler/session_handler.go`, add the handler that will render this form:

{{< file "golang/018-session-handler.go" "go" >}}

In `main.go`, add the new route at `GET /sign-in`:

{{< file "golang/019-main.go" "go {hl_lines=[13 14 15] linenostart=13}" >}}

If you navigate to [http://localhost:3000/sign-in](http://localhost:3000/sign-in), you should see a login page like this:

{{< figure "/golang/05-sign-in.png" "The sign in view at 150% zoom." >}}

